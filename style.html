<!-- -*- mode:HTML; coding: utf-8 -*- -->
<!-- $Id$ -->
<!--#include virtual="header.shtml"-->

<h2>Стиль форматирования программ</h2>

<p>Следование этому стилю оформления программ обязательно для всех
сдаваемых программ.</p>

<h3>1. Набор символов</h3>

<p>1.1. В тексте программы запрещено использование любых управляющих символов,
кроме символов &quot;Перевода строки&quot; LF (код 10) и
&quot;Возврата каретки&quot; CR (код 13). К управляющим относятся символы
с кодами от 0 до 31 и символ с кодом 127.
</p>

<p>1.2. Этот запрет включает в себя запрет на использование символа табуляции
(код 9). Все отступы в программе должны быть сделаны только с использованием
символа пробела.</p>

<h3>2. Отступы и ширина текста</h3>

<p>2.1. Размер отступа &mdash; 4 символа. Прочие отступы не допускаются (кроме исключения в п. 2.3 и 4.5.3).
</p>

<p>2.2.
Ширина текста программы (то есть количество символов в одной строке
кода) не должна превышать 100 символов.
</p>

<p>2.3. <font color="green">В случаях, когда длинная конструкция программы размещается на нескольких строках, так как не помещается в одну, для продолжения
длинной строки на следующих строках используется отступ <b>8 символов</b> относительно отступа первой части длинной строки.</font> Например:</p>
<pre>
    if (a &gt; b
            &amp;&amp; c &lt; d) {
        call_function();
    }
</pre>

<h3>3. Имена</h3>

<p>3.1. Имена глобальных переменных и функций должны быть осмысленными
и отражать назначение. Слишком длинные имена, однако, не рекомендуются.
В именах допускаются сокращения, которые не затрудняют понимание имени
и назначения функций и переменных.
</p>

<p>3.2. В именах должны использоваться только английские слова.
Транслитерации русских слов не допускаются.
</p>

<p>Например, имя функции <tt style="color: red;">f</tt> является недопустимым.
Имена функций <tt>calculate_square_root</tt> и <tt>calc_sqrt</tt>
допустимы, но последнее предпочтительнее, так как короче и использует
общепринятые сокращения. Имя функции <tt style="color: red;">vychislenie_kornya</tt>
недопустимо, так как использует русские слова.
</p>

<p>3.3. Имена констант записываются полностью заглавными буквами.
Если имя константы состоит из нескольких слов, для их разделения
используются подчеркивания. Например,
<tt>RED</tt>, <tt>POLL_INTERVAL</tt>.
</p>

<p>3.4. Имена переменных, функций и меток записываются полностью строчными
буквами. Если имя состоит из нескольких слов, для их разделения используются
символы подчеркивания. Например, <tt>buf</tt> (допустимое сокращение от слова
<tt>buffer</tt>), <tt>create_tree</tt>. В случаях, оговоренных
преподавателями, допускаются отступления от правила именования функций.
</p>

<p>3.5. В именах <b>не допускается</b>
использование каких-либо префиксов или суффиксов,
отражающих тип объекта (т. н. венгерская нотация),
например, <tt style="color: red;">a_crszkvc30LastNameCol</tt>.
</p>

<p>3.6. Имена типов и тегов начинаются с заглавной буквы.
Каждое новое слово в имени начинается с заглавной буквы.
Например, <tt>Node</tt>, <tt>BinaryOperation</tt>.
</p>

<p>3.7. Имена не должны вызывать визуальные затруднения при прочтении.
Например, переменная с именем <tt style="color: red">l</tt>
или константа с именем <tt style="color: red">I</tt>
недопустимы, так как могут быть спутаны с числом <tt>1</tt>.
То же правило применимо к константе <tt style="color: red">O</tt>.
</p>

<h3>4. Стиль отступов</h3>

<h4>4.1. Структурные типы</h4>

<p>Определения структурных типов оформляются следующим образом:
<pre>
struct StructureType
{
    int field1;
    int field2;
    char *field3;
};
</pre>
или следующим образом:
<pre>
typedef struct Node
{
    struct Node *next;
    double data;
} Node;
</pre>
Каждое определение поля структуры записывается на отдельной строке.
Не допускается объединять определение переменной и структуры,
например, следующая запись недопустима:
<pre style="color: red; ">
struct Foo
{
    int fudge;
} foos[10];
</pre>
</p>

<p>(C++) Определения классов записываются следующим образом:</p>
<pre>
class Complex
{
    double re, im;
public:
    Complex(double re_, double im_) : re(re_), im(im_) {}
};
</pre>

<p>Не допускается именование полей классов ни с префиксом <tt>m</tt>,
ни с суффиксом <tt>_</tt>, таким образом неправильно:</p>
<pre style="color: red; ">
class Complex1
{
    double re_, im_;
};

class Complex2
{
    double m_re, m_im;
};
</pre>

<h4>4.2. Перечислимые типы</h4>

<p>Определения перечислимых типов оформляются следующим образом:
<pre>
enum Colours
{
    RED,
    GREEN
};
</pre>
или следующим образом:
<pre>
typedef enum Colours
{
    RED,
    GREEN
} Colours;
</pre>
</p>

<p>
Допускается использование анонимных перечислений:
<pre>
enum
{
    READY_BIT = 0x1,
    ERROR_BIT = 0x2
};
</pre>
</p>

<p>
Если определяется единственная константа, допускается запись анонимного
перечисление в одной строке:
<pre>
enum { BUFFER_SIZE = 1024 };
</pre>

<h4>4.3. Указатели</h4>

<p>При объявлении переменных указательного типа знак <tt>*</tt> относится
к имени переменной, а не к имени типа. Пробел между <tt>*</tt> и именем
переменной не ставится.</p>

<p>Правильно:
<pre>
int *p;
char *str, **pstr;
</pre>
</p>

<p>Неправильно:
<pre style="color:red">
int* p;
int* q, r;
char * * * s;
</pre>
</p>

<h4>4.4. Инициализация</h4>

<p>4.4.1. Инициализация составных типов оформляется так, чтобы была понятна
структура инициализационных данных. Например:
<pre>
int matrix[3][2] =
{
    { 4, 5 },
    { 10, 2 },
    { 1, 1 }
};
</pre>
</p>

<p>Не допускается пропускать фигурные скобки вложенного инициализатора,
даже если они и не обязательны. Например,
<pre style="color: red">
int matrix[3][2] =
{
    4, 5, 10, 2, 1, 1
};
</pre>
</p>

<p>4.4.2. Инициализация простых и указательных типов
записывается на той же строке, что и
определение, например:
<pre>
double summ = 0.0;
</pre>
</p>

<p>4.4.3. Инициализация символьных строк записывается, как правило,
на той же строке, что и определение переменной.
<pre>
char errmsg[] = "No error";
</pre>
Если строка достаточно длинная, допускается разбивать инициализацию на
несколько строк текста.
<pre>
char *helpmsg =
"hello: my first program\n"
"  usage: hello world\n";
</pre>

<p>4.4.4. Для инициализации локальных структур нулями
используйте функцию <tt>memset</tt>.
Даже если некоторые поля структуры инициализируются ненулевыми
значениями, предварительно вся структура должна быть
обнулена.
</p>

<p>4.4.5.
Если локальная переменная инициализируется сложным выражением
(то есть не константой), каждое такое определение переменной
должно записываться на отдельной строке.
</p>

<p>Неправильно:</p>
<pre style="color: red">
    int var1 = some_func(params), var2 = some_other_func(params);
</pre>

<p>Правильно:</p>
<pre>
    int var1 = some_func(params);
    int var2 = some_other_func(params);
</pre>

<h4>4.5. Функции</h4>

<p>4.5.1. Определение функции записывается следующим образом:
<pre>
char *
copy_str(const char *instr)
{
}
</pre>
То есть тип возвращаемого значения, квалификаторы типа и классы памяти
записываются на отдельной строке. Имя функции начинается с первой позиции,
между именем функции и открывающей скобкой пробелы не ставятся.
Открывающая и закрывающая фигурные скобки блока функции располагаются
каждая на отдельной строке на первой позиции.
</p>

<p>4.5.2. Если функция не принимает параметров, в списке параметров
обязательно указание ключевого слова <tt>void</tt>.
<pre>
int
random(void)
{
}
</pre>
</p>

<p>4.5.3. Если у функции становится много параметров, определение функции
записывается так, чтобы каждый параметр располагался на отдельной
строке с отступом <font color="green"><b>8 символов</b>.
Открывающая фигурная скобка тела функции <b>должна</b> размещаться
на отдельной строке.</font> (Много параметров &mdash; это когда длина строки,
содержащей имя функции, начинает превышать 70 символов.)
<pre>
static void
callback_handler(
        int param1,
        int param2)
{
}
</pre>
</p>

<h4>4.6. Операторы</h4>

<p>4.6.1. Оператор <tt>if</tt> без <tt>else</tt> записывается
следующим образом.
<pre>
    if (test) {
        statements...
    }
</pre>
<tt>if</tt> и открывающая скобка, а также закрывающая скобка и
открывающая фигурная скобка отделяются одним пробелом.
Закрывающая фигурная скобка находится на отдельной строке.
</p>

<p>4.6.2. Оператор <tt>if</tt> с <tt>else</tt> записывается
следующим образом.
<pre>
    if (test) {
        statements...
    } else {
        statements...
    }
</pre>
</p>

<p>4.6.3. Цепочка операторов <tt>if</tt>, <tt>else if</tt>, <tt>else</tt>
записывается следующим образом.
<pre>
    if (test1) {
        statements...
    } else if (test2) {
        statements...
    } else {
        statements...
    }
</pre>
</p>

<p>4.6.4.
Оператор <tt>while</tt> записывается следующим образом:
<pre>
    while (test) {
        statements...
    }
</pre>
</p>

<p>4.6.6.
Оператор <tt>do while</tt> записывается следующим образом:
<pre>
    do {
        statements...
    } while (test);
</pre>
</p>

<p>4.6.7.
Оператор <tt>for</tt> записывается следующим образом:
<pre>
    for (init; test; update) {
        statements...
    }
</pre>
</p>

<p>4.6.8.
Оператор <tt>switch</tt> записывается следующим образом:
<pre>
    switch (expr) {
    case LABEL1:
        statements...
        break;
    case LABEL2:
        statements...
        break;
    default:
        statements...
        break;
    }
</pre>
</p>

<p>4.6.9.
В операторах <tt>if</tt>, <tt>while</tt>, <tt>do-while</tt>, <tt>for</tt>
тело цикла заключается в фигурные скобки (составной оператор),
даже если тело &mdash; единственный оператор.
</p>

<p>4.6.10.
Операторы вычисления выражения размещаются каждый на отдельной строке.
Пример:
<pre>
    a = b;
    b = c;
</pre>
</p>

<p>4.6.11.
Метки записываются с первой позиции вне зависимости от текущего отступа
блока. Каждая метка записывается на отдельной строке.
<pre>
void
func(void)
{
    for (...) {
        for (...) {
        }
exit1:;
    }
}
</pre>
</p>

<p>4.6.12.
Использование оператора <tt>goto</tt> настоятельно не рекомендуется.
Допускается использование оператора <tt>goto</tt> при обработке ошибок
и при выходе из вложенных циклов. Допускаются только переходы
вперед по тексту программы.
</p>

<p>4.6.13. (C++)
Оператор try-catch записывается следующим образом:
<pre>
    try {
    } catch (ex1 e1) {
    } catch (ex2 e2) {
    }
</pre>
Типы обрабатываемых исключений должны быть упорядочены от более специализированных
к более общим. Объекты исключений пользовательских типов должны передаваться
по константной ссылке.
</p>

<h4>4.7. Операции</h4>

<p>4.7.1.
Бинарные операции <tt>+</tt>, <tt>*</tt> и пр.
отделяются пробелами от аргументов, например,
<pre>
a + b, a != 0, d &gt;= a
</pre>
</p>

<p>4.7.2.
Операции доступа к полю <tt>.</tt> и <tt>-&gt;</tt>
бинарной операцией не считаются, поэтому пробелами не
окружаются. Скобки <tt>[</tt>, <tt>]</tt> пробелами не окружаются.
Примеры:
<pre>
var.field, var-&gt;field, var-&gt;do_method(), arr[i][j]
</pre>
</p>

<p>4.7.3.
После запятой во всех случаях и после точки с запятой в заголовке цикла
<tt>for</tt> ставится один символ пробела.
<pre>
    int a, b, c = 0;
    printf("%d\n", n);
    for (i = 0; i &lt; 10; ++i)
</pre>
</p>

<p>4.7.4.
Между унарной операцией и операндом пробел не ставится. Примеры:
<pre>
    b = *a;
    i++;
    *p++ = 0;
</pre>
</p>

<p>4.7.5.
Между именем функции и открывающей скобкой пробелы не ставятся.
<pre>
    printf("%d\n", value);
    while ((c = getchar()) != EOF);
</pre>
</p>

<p>4.7.6.
После открывающей скобки и перед закрывающей скобкой пробел не ставится.
</p>

<p>4.7.7.
После закрывающей скобки операции приведения типов
ставится один пробел.
</p>
<pre>
    (unsigned char *) str
</pre>

<p>4.7.8.
Конструкции <tt style="color: red;">*(a + i)</tt>,
<tt style="color: red;">(*p).f</tt> запрещены.
Используйте <tt>a[i]</tt> и <tt>p-&gt;f</tt> соответственно.
</p>

<p>4.7.9.
В выражении не должны присутствовать заведомо лишние скобки.
</p>

<p>Неправильно:</p>
<pre style="color:red">
    if ((a &gt; 0) &amp;&amp; (!(b))) {
    }
</pre>

<p>Правильно:</p>
<pre>
    if (a &gt; 0 &amp;&amp; !b) {
    }
</pre>

<h3>5. Использование элементов языка и библиотек</h3>

<p>5.1.
В тексте программы не допускается использование явных литералов целого
и вещественного типов, не объявленных как константы, кроме следующих случаев:
<ul>
<li>Константы <tt>0</tt> и <tt>1</tt> без ограничений.</li>
<li>Константа <tt>2</tt>, когда она обозначает файловый дескриптор потока
ошибок.</li>
<li>Константа <tt>-1</tt> как специальное значение, сигнализирующее
об ошибке.</li>
</ul>
</p>

<p>Следующий фрагмент недопустим, так используется константа <tt>10</tt>.
<pre style="color: red">
    for (i = 0; i < 10; ++i) {
    }
</pre>
</p>

<p>5.2.
Для определения констант целых типов не разрешается использовать
ни директиву <tt>#define</tt>, ни квалификатор <tt>const</tt>.
Все целые константы должны определяться с помощью ключевого слова
<tt>enum</tt> и иметь осмысленные имена.
</p>

<p>Неправильно:</p>
<pre style="color: red">
#define BUFSIZE 1024       // использование #define
const int BOARD_WIDTH = 8; // использование const
enum { TEN = 10 };         // бессмысленное имя
</pre>

<p>5.3.
Стандартные заголовочные файлы должны подключаться с помощью директивы
</p>
<pre>
#include &lt;FILE&gt;
</pre>

<p>Пользовательские заголовочные файлы должны подключаться с
помощью директивы</p>
<pre>
#include &quot;FILE&quot;
</pre>

<p>Неправильно:</p>
<pre style="color: red">
#include &quot;stdio.h&quot;    // стандартный заголовочный файл
#include &lt;tree.h&gt;         // пользовательский заголовочный файл
</pre>

<p>5.4.
Все сообщения об ошибках, предупреждения, отладочные сообщения
и прочая диагностическая информация, не являющаяся результатом
работы программы в предположении корректных входных данных,
должна выводиться на стандартный поток ошибок <tt>stderr</tt>.
</p>

<p>5.5.
Каждое диагностическое сообщение должно заканчиваться
символом перехода на новую строку.
</p>

<p>5.6.
При выводе результата работы на стандартный поток вывода или в
текстовый файл вывод должен заканчиваться символом
перехода на новую строку. Исключением являются программы, выполняющие
посимвольную обработку потока данных.
</p>

<p>Например, неправильно:
<pre style="color: red">
int
main(void)
{
    int a, b;
    scanf(&quot;%d%d&quot;, &amp;a, &amp;b);
    printf(&quot;%d&quot;, a + b);
    return 0;
}
</pre>
</p>

<p>Но правильно:
<pre>
int
main(void)
{
    int a, b;
    scanf(&quot;%d%d&quot;, &amp;a, &amp;b);
    printf(&quot;%d\n&quot;, a + b);
    return 0;
}
</pre>
</p>

<p>5.7.
Работа функции <tt>main</tt> должна заканчиваться выполнением
оператора <tt>return</tt> с соответствующим кодом завершения.
Код завершения &mdash; это число в диапазоне [0, 128).
</p>

<p>5.8.
Использование функций, не проверяющих переполнение буфера,
запрещено. К таким функциям относятся: <tt>gets</tt>,
<tt>sprintf</tt>, <tt>strcpy</tt>, <tt>strcat</tt>.
Использование спецификатора <tt>%s</tt> функций <tt>scanf</tt> 
и <tt>fscanf</tt> без указания максимального количества вводимых
символов запрещено. Использование функций <tt>strncpy</tt>,
<tt>strncat</tt> запрещено.
</p>

<p>5.9.
Использование функции <tt>malloc</tt> не рекомендуется.
Допускается использовать <tt>malloc</tt> при реализации
расширяемых массивов, если предполагается выполнять
<tt>realloc</tt>. Во всех остальных случаях
используйте функцию <tt>calloc</tt>.
Запрещается использовать <tt>malloc</tt> при выделении
памяти под элементы списков, деревьев и прочих подобных
структур.
</p>

<p>5.10.
Запрещается использовать конструкцию <tt>sizeof(TYPE)</tt>,
если ее можно заменить конструкцией <tt>sizeof(VALUE)</tt>.
</p>

<p>Например, неправильно:
<pre style="color: red">
    struct List *p = calloc(1, sizeof(struct List));
</pre>
</p>

<p>Правильно:
<pre>
    struct List *p = calloc(1, sizeof(*p));
</pre>
</p>

<p>5.11.
Даже при операциях с массивами элементов типа <tt>char</tt>
необходимо вычислять размер с помощью умножения количества элементов
на размер одного элемента.
<p>Неправильно:
<pre style="color: red">
    s = realloc(s, sz);
</pre>
</p>

<p>Правильно:
<pre>
    s = realloc(s, sz * sizeof(s[0]));
</pre>
</p>

<p>5.12.
В программе не должны присутствовать закомментированные строки кода,
которые использовались для отладки.
</p>

<p>5.13.
Вспомогательные функции общего назначения (такие, как <tt>getline</tt>,
функции работы со списками и т. д.) не должны ничего выводить
на <tt>stdout</tt> или <tt>stderr</tt>. В случае возникновения
ошибки такие функции должны, как правило, возвращать специальное
значение.
</p>

<p>5.14.
Глобальные переменные должны использоваться только при необходимости.
Передача параметров предпочтительнее использования глобальных переменных.
</p>

<p>5.15.
Локальные массивы константного и небольшого (до 64кб) размера должны создаваться
на стеке, а не в динамической памяти.
</p>

<p>Неправильно:</p>
<pre style="color: red">
{
    char *buf = calloc(PATH_MAX, sizeof(*buf));
    // ...
    free(buf);
}
</pre>

<p>Правильно:</p>
<pre>
{
    char buf[PATH_MAX];
}
</pre>

<p>5.16.
Запрещается использовать локальные массивы переменного размера.
</p>
<p>Неправильно:
<pre style="color: red">
    scanf("%d", &size);
    double arr[size];
</pre>
</p>

<p>5.17.
Переменные, которые хранят дескрипторы ресурсов (файловые дескрипторы,
дескрипторы потоков FILE *, указатели в динамическую память и пр.)
должны определяться в начале функции и инициализироваться либо корректным
значением дескриптора ресурса, либо специальным значением, обозначающим,
что ресурс не выделен. Все ресурсы должны освобождаться когда становятся
ненужными.
</p>
<p>Неправильно:
<pre style="color: red">
void
func(void)
{
    some_code();
    char *s;
    some_other_code();
    s = calloc(size, sizeof(*s));
    still_some_code();
}
</pre>
</p>

<p>Правильно:
<pre>
void
func(void)
{
    char *s = NULL;
    some_code();
    some_other_code();
    s = calloc(size, sizeof(*s));
    still_some_code();
    free(s);
}
</pre>
</p>

<p>5.18. (только для C)
Запрещается использовать явное приведение типа результата, возвращаемого функциями
<tt>malloc</tt>, <tt>calloc</tt>, <tt>realloc</tt>.
</p>
<p>Неправильно:
<pre style="color: red">
    double *ptr = (double*) calloc(init_size, sizeof(*ptr));
</pre>
</p>

<p>Правильно:
<pre>
    double *ptr = calloc(init_size, sizeof(*ptr));
</pre>
</p>

<h3>6. Многомодульные программы</h3>

<p>6.1.
Каждая независимо компилируемая единица программы (модуль) должна состоять из двух файлов: файла
с суффиксом .h (заголовочного файла), содержащего определения типов данных, констант и прототипов функций,
и файла с суффиксом .c (файла реализации), содержащего тела функций. Головной модуль (исходный файл,
содержащий функцию main) может не иметь соответствующего .h файла.
</p>

<p>6.2.
Заголовочный файл должен быть защищен от повторного включения. Например, если файл называется module.h, то защита
от повторного включения может реализовываться следующим образом:
</p>
<pre>
#ifndef MODULE_H_INCLUDED
#define MODULE_H_INCLUDED
// текст файла
#endif
</pre>

<p>6.3.
Заголовочный файл модуля должен обязательно включаться в файл реализации этого модуля. Другими словами,
в файле module.c должна быть обязательно директива
</p>
<pre>#include "module.h"</pre>

<p>6.4.
Заголовочный файл модуля должен обязательно включаться во все файлы, которые используют сущности,
определенные в этом заголовочном файле.
</p>

<p>6.5.
Заголовочный файл должен содержать минимальное количество директив #include - только те, в которых
определяются сущности, используемые в этом заголовочном файле. Если сущности используются
в соответствующем файле реализации,
но не в данном заголовочном файле, то и включаться требуемый заголовочный файл должен в файле реализации.
</p>

<p>6.6.
Для сборки проекта в каталоге проекта должен присутствовать Makefile, содержащий правила all для сборки всего проекта и clean
для очистки всех файлов, возникающих при компиляции (объектных и исполняемых файлов).
</p>

<!--#include virtual="footer.shtml"-->
